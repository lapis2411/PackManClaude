# パックマン風ゲーム開発タスクリスト (for Code Agent)

## 概要
Go言語とEbitengineを使用し、パックマン風のゲームを開発する。外部アセット（画像、音声ファイル）は使用せず、全てのオブジェクトは `ebiten/vector` パッケージによる図形描画で実現すること。

---

### タスク #1: `build: プロジェクトの初期設定とウィンドウ表示`
**ゴール:** ゲームの基本的な枠組みを構築し、空のウィンドウを表示する。

* **指示:**
    * Goモジュールを初期化せよ (`go mod init`)。
    * Ebitengine (`github.com/hajimehoshi/ebiten/v2`) をプロジェクトに追加せよ。
    * `main.go`ファイルを作成し、`Game`構造体を定義せよ。この構造体は`ebiten.Game`インターフェースを実装すること。
    * `Update`メソッドは空でよい。
    * `Draw`メソッドも空でよい。
    * `Layout`メソッドは固定のゲーム画面サイズ (例: 640x480) を返すこと。
    * `main`関数で`ebiten.RunGame(&Game{})`を呼び出し、タイトル付きの空ウィンドウが表示されることを確認せよ。

---

### タスク #2: `feat: 静的な迷路の描画`
**ゴール:** ゲームの舞台となる迷路を画面に描画する。

* **指示:**
    * 迷路のレイアウトを `[][]int` 型のスライスで定義せよ。`0`は通路、`1`は壁とする。
    * 定数として `TileSize` (例: 20) を定義せよ。
    * `Game`構造体の`Draw`メソッド内で、迷路データを走査せよ。
    * 値が`1`の要素に対応する位置に、`ebiten/vector` パッケージを使用して矩形（壁）を描画せよ。壁の色は任意（例: 青色）でよい。

---

### タスク #3: `feat: プレイヤーの表示とキーボード操作`
**ゴール:** プレイヤーを円形で描画し、キーボードで操作できるようにする。

* **指示:**
    * `Player`構造体を定義せよ。フィールドとして `X`, `Y` (座標) と `Speed` (移動速度) を `float64` 型で持つこと。
    * `Player`を円形 (`vector.DrawCircle`) で描画せよ。色は黄色 (`color.RGBA{R: 0xff, G: 0xff, B: 0, A: 0xff}`) とすること。
    * `Player`の`Update`メソッドを実装せよ。
    * `ebiten.IsKeyPressed` を使用し、矢印キー（`ebiten.KeyArrowUp`など）の入力に応じてプレイヤーの座標を更新せよ。
    * 移動先の座標が壁 (`1`) と衝突しないように、当たり判定ロジックを実装すること。プレイヤーは壁タイルを通り抜けることはできない。

---

### タスク #4: `feat: ドットとパワークッキーの配置と取得`
**ゴール:** 収集アイテムであるドットとパワークッキーを配置し、プレイヤーが取得できるようにする。

* **指示:**
    * 迷路データに新しい値を追加せよ。`2`はドット、`3`はパワークッキーとする。
    * 迷路データに基づき、ドットとパワークッキーを描画せよ。
        * ドット: 小さな円形（例: 半径2ピクセル）、色は白。
        * パワークッキー: やや大きな円形（例: 半径5ピクセル）、色は白。
    * プレイヤーがドットまたはパワークッキーと重なったら、そのアイテムを迷路データから削除（値を`0`にする）するロジックを実装せよ。
    * `Game`構造体に`Score`フィールドを追加し、ドット取得時にスコアを加算せよ。

---

### タスク #5: `feat: ゴーストの表示とランダム移動`
**ゴール:** 敵キャラクターであるゴーストを配置し、単純な移動AIを実装する。

* **指示:**
    * `Ghost`構造体を定義せよ。`Player`と同様に座標と速度のフィールドを持つこと。
    * ゴーストを1体、矩形または円形で描画せよ。色は赤色とすること。
    * `Ghost`の`Update`メソッドを実装せよ。
    * ゴーストが壁に衝突せず、通路に沿って移動するロジックを実装せよ。
    * 通路の分岐点に到達した場合、進行可能な方向からランダムに一つを選択して移動する単純なAIを実装せよ。

---

### タスク #6: `feat: ゲームの状態管理（シーンマネージャー）`
**ゴール:** ゲームの各画面（プレイ中、ゲームオーバーなど）を管理する仕組みを導入する。

* **指示:**
    * `Scene`インターフェースを定義せよ。このインターフェースは `Update() Scene` と `Draw(*ebiten.Image)` メソッドを持つこと。`Update`メソッドは次のシーンを返すことでシーン遷移を可能にする。
    * `GameScene`（現在のゲームロジック）と、空の`GameOverScene`を`Scene`インターフェースを実装する形で作成せよ。
    * `Game`構造体をシーンマネージャーとして機能させ、現在のシーンの`Update`と`Draw`を呼び出すように修正せよ。

---

### タスク #7: `feat: プレイヤーとゴーストの衝突判定`
**ゴール:** プレイヤーとゴーストの衝突を検知し、ゲームオーバー処理を実装する。

* **指示:**
    * `GameScene`の`Update`メソッド内で、プレイヤーの矩形とゴーストの矩形が重なっているか判定するロジックを実装せよ。
    * 衝突が検知された場合、`GameScene`の`Update`メソッドが`GameOverScene`の新しいインスタンスを返すように変更せよ。これによりゲームオーバー画面に遷移する。
    * `GameOverScene`には、「GAME OVER」というテキストを`ebiten/text/v2`を使用して表示せよ。

---

### タスク #8: `feat: パワークッキーの効果（ゴーストのイジケ状態）`
**ゴール:** パワークッキー取得時にゴーストが一時的に弱体化する機能を実装する。

* **指示:**
    * `Ghost`構造体に状態を表すフィールド（例: `State`）と、イジケ状態の持続時間を管理するタイマー（例: `FrightenedTimer`）を追加せよ。
    * プレイヤーがパワークッキーを取得したら、ゴーストの状態を「イジケ状態」に変更し、タイマーを設定せよ。
    * イジケ状態のゴーストは色を青色に変更して描画せよ。
    * イジケ状態のゴーストにプレイヤーが触れた場合、ゴーストは初期位置に戻り、スコアが加算される。この時点ではゲームオーバーにはならない。
    * タイマーが0になったら、ゴーストは通常状態に戻ること。

---

### タスク #9: `refactor: ゴーストAIの強化（追跡アルゴリズム）`
**ゴール:** ゴーストの移動AIをランダム移動からプレイヤーを追跡するアルゴリズムに変更する。

* **指示:**
    * ゴーストの移動ロジックを修正し、ターゲット座標に向かって最短経路で移動するように変更せよ。（A*アルゴリズムなどの複雑な実装は不要。分岐点でターゲットに最も近づく方向を選択する単純なロジックでよい）
    * ゴーストのターゲット座標をプレイヤーの現在位置とせよ。
    * イジケ状態のゴーストは、プレイヤーから離れるように移動するロジックに変更せよ。

---

### タスク #10: `feat: UIの整備とステージクリア`
**ゴール:** スコアを表示し、ステージクリアの条件を実装する。

* **指示:**
    * `ebiten/text/v2`を使用し、ゲーム画面の隅に現在のスコアをリアルタイムで描画せよ。
    * `GameScene`の`Update`メソッドで、ステージ上の全てのドットとパワークッキーがなくなったかを毎フレームチェックせよ。
    * 全てのアイテムがなくなったらクリアとし、「STAGE CLEAR」のようなテキストを表示してゲームを停止させるロジックを実装せよ。